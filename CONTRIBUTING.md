# Contributions #

To separate source code, programme configurations, application data,
the respository is structured as follows:

```text
____. (root)
    |
    |____ /assets
    |    |_ ... # data e.g. translations
    |
    |____ /setup
    |    |_ ... # contains configuration of app
    |
    |____ /src
    |    |_ ... # source code
    |
    |____ /models
    |    |_ /generated
    |    | |_ ... # .gitignore'd models generated by schemata
    |    |
    |    |_ ... # schemata for data models
    |
    |____ /templates
    |    |_ ... # contains templates for private files to be defined by developer
    |
    |____ /tests
    |    |_ /integration
    |    | |_ ... # integration tests
    |    |_
    |    |_ ... # rest are for unit tests
    |    |_
    |    |_ initialise.py # <- used to create session for integration tests
    |
    |
    |_ .env           # .gitignore'd environment file
    |_ Makefile       # need GNU make to use
    |_ pyproject.toml # configuration for automatic testing
```

In this file we document how developers can organise and contribute to the development of the application.

----

**Table of contents**

- [Contributions](#contributions)
  - [Workflow guidelines](#workflow-guidelines)
    - [Branches](#branches)
    - [Commits](#commits)
    - [Ticket Definition](#ticket-definition)
    - [Ticket in Doing](#ticket-in-doing)
    - [Ticket Review](#ticket-review)
    - [Ticket Merge-Strategie](#ticket-merge-strategie)
  - [Basic setup for developers](#basic-setup-for-developers)
    - [Bot Token](#bot-token)
    - [Environment File](#environment-file)
    - [System requirements](#system-requirements)
    - [Basic commands](#basic-commands)
  - [Deployment and Logging](#deployment-and-logging)
    - [Docker](#docker)
    - [Deployment of live test bot](#deployment-of-live-test-bot)
    - [Deployment of live production bot](#deployment-of-live-production-bot)
    - [Logging](#logging)
  - [Development notes](#development-notes)
    - [Develop new redirect command](#develop-new-redirect-command)
    - [Develop new special command](#develop-new-special-command)
  - [Testing notes](#testing-notes)
    - [Automatic testing](#automatic-testing)
    - [Live testing (local)](#live-testing-local)
    - [Live testing (deployed)](#live-testing-deployed)
----

## Workflow guidelines ##

Since the development of this application is a collaborative effort,
in order to keep development smoothly we would like to keep to the following guidlines.

### Branches ###

The relation between branches is as follows:
```text
-----------------------------------------> main
  \______> staging _________________/
     ||                         ||
     || all other branches:     ||
     ||                         ||
     ||__> dev-branch-unicorns__||
     |___> hotfix-error-404______|
       ...
```
where 'all else' includes **dev**, **hotfix**, and **bugfix** branches.

!!! The **main** branch and **staging** branches are hosted
and correspond to the live production and test applications respectively.

!!! So, unless absolutely trivial (and agreed upon), we should **never** push to main.

In each ticket a branch (off **staging**) should be created with a appropriate name according to the scheme:

- `tbot-n` where `n` is in ticket number.
- `bug-xxxx` where `xxxx` is in snake case, for bug tickets.
- `hotfix-xxxx` where `xxxx` is in snake case, for hotfix tickets (these are like bug tickets but have special priority).

### Commits ###

When committing please use the following scheme:
```text
{branch-from} > {branch-to}: {message}
```
Where:

- `{branch-from}` = name of branch
- `{branch-to}` = name of parent branch, to which the branch will be merged at the end of development.
  This is usually **staging**.
- `{message}` the commit message. This should contain a short description of what was done.
  Any longer descriptions should be added after a line break.

This **schema** makes reading lots of parallel changes in different branches easier to filter with the eye.

### Ticket Definition ###

1. Before ticket fully defined, keep it in 'backlog' with a `define me`-label
2. Add objectives as a _TODO_ checklist (acceptance criteria).
3. If the ticket is a Bug or Hotfix (= bug but with higher prio),
   add `[Bug]` or `[Hotfix]` to the start of the title.
4. Once ticket fully defined, remove the `define me`-label.

### Ticket in Doing ###

(provided ticket is fully defined and does not have `define me`-label)

1. Drag ticket from 'backlog' to 'doing' and assign your face to it.
2. Create a branch _from_ the staging branch according to the above scheme.
    </br>
    Note the name of the Branch in the ticket description.
3. When ticket completed (everything in _TODO_ list marked [x]):
    - create a pull request (branch ---> **staging**);
    - add a _How to Review_ checklist;
    - remove your face from ticket;
    - drag ticket into 'review'.

Please note the information in the [devlopment section](#development-notes) below.
It is also advisory to use [local testing](#local-testing) whilst developing.

### Ticket Review ###

(Tickets should only be reviewed by a different developer from the one in 'doing'.)

1. Assign your face to ticket.
2. Go through all the checks in the checklist (+ generally check that the general bot behaviour is not faulty).
    - If the review has open issues:
        1. if issue is large, add new points to _TODO_ and drag ticket into 'More work needed'.
        2. if issue small, clarify them with the original developer and then complete the below steps.
    - If the review is successful
        1. complete [merging](#ticket-merge-strategie);
        2. remove your face from ticket and drag to 'Done'.

See the [testing section](#testing-notes) below for information about local/live testing.

### Ticket Merge-Strategie ###

!!! Never merge directly to **main** branch !!!

Order is **ticket branch** ---> **staging** ---> **main**.

1. Change the Version in [dist/Version](dist/Version) and [pyproject.toml](pyproject.toml).
2. Commit this change, and accept the PR.
   </br>
   You may delete the branch when done
   </br>
   (but _do not_ delete **staging**!).
   </br>
   Ensure that live test instance of the app has been successfully [deployed](#deployment-of-live-test-bot).
3. _Only if_ we want to release the changes properly, create a PR **staging ---> main**.
    </br>
    (This should automatically be the case for hotfixes.)
    </br>
    Perform [live tests](#live-tests) on the instance of the application before accepting this PR.
    </br>
    **Do NOT** delete the staging branch!
    </br>
    Ensure that live production instance of the app has been successfully [deployed](#deployment-of-live-production-bot).

----

## Basic setup for developers ##

### Bot Token ###

In order to deploy or test, you need to speak to the `@BotFather` first.
We did this to set up the **staging bot** and the **production bot**.
You need to similarly set up your own private bot for local testing.

Do this once:

- Search for and open a chat with the Telegram user named `@BotFather`.
- In the chat, use the `/newbot` command to create a new bot.
- Ask the `@BotFather` for the bot's API token and keep a note of this.
- Create a group just for you and `@<name-of-local-test-bot>`.
  </br>
  Ensure you and `@<name-of-local-test-bot>` have admin status.
  </br>
  The `@<name-of-local-test-bot>` only needs rights to delete messages.

### Environment File ###

Create a **.env**-file in the root directory with (at least) the following contents:
```.env
token={your API Token}
```
where the token is either the token of your local bot or
(for deployment purposes) the staging/production bots.

See [templates/.env](templates/.env) for full template containing all necessary attributes.

### System requirements ###

- We use `Python 3.10.*` (but theoretically `3.8.*` and `3.9.*` should work too).
- Ensure that the [pip command is installed](https://pip.pypa.io/en/stable/installation/).
- Ensure you have:
  - bash
  - the GNU-Make tool
  - docker + docker cli (Windows users need to install WSDL2).

### Basic commands ###

The following commands can be used to build, test, run, clean:
```bash
make build
make tests
make tests-unit # just unit tests
make tests-integration # just integration tests
make run
make clean # to remove all artefacts for a fresh start
```

----

## Deployment and Logging ##

### Docker ###

(_under construction_)

- Ensure that the bot token is set in the **.env** file (_cf._ [basic setup](#basic-setup-for-developers)).
- Ensure that docker and docker-cli are installed.
- Call any of:
  ```bash
  docker-compose up run
  docker-compose up tests
  ```

Note that the services currently branch off one single service (`basic`).
So you can repeatedly call `docker-compose build <service name>`
in the order of dependencies, until you reach the desired service,
then call `docker-compose up` on the final service.
But `docker-compose up <final service>` does this automatically.

### Deployment of live test bot ###

- Log in to our deployment tool.
- Select the app **leipzig-helps-ukraine** (staging).
- Check the latest activity. If the app is not running:
  - open the _Deploy_ tab
  - select 'staging' in both automatic and manual deployment
  - deploy the branch.

Also check the logs (see below).

### Deployment of live production bot ###

- Log in to our deployment tool.
- Select the app **leipzig-helps-ukraine** (production).
- Check the latest activity. If the app is not running:
  - open the _Deploy_ tab
  - select 'staging' in both automatic and manual deployment
  - deploy the branch.

Also check the logs (see below).

### Logging ###

In the deployment tool select _Overview_ then select the logging add-on.

----

## Development notes ##

We document here how to set up and provide hints regarding the development of simple changes.

### Develop new redirect command ###

To add a new redirect button, the following parts have to be changed:

- [setup/config.yaml](setup/config.yaml) -> add a command
  (cf. commands like `/transport`, `/housing`, _etc._).
- [assets/language.yaml](assets/language.yaml) -> if necessary add translations for new keyword.

And that's it! No need to add any code!

### Develop new special command ###

To add a new special command (amongst `/start`, `/help`, `/pin`, _etc._),
the following parts have to be changed:

- [setup/config.yaml](setup/config.yaml) -> add a command.
- [assets/language.yaml](assets/language.yaml) -> if necessary add translations for new keyword.
- [behaviour ---> actions](src/behaviour/actions/universal.py) -> „ergänze“ `universal_action` to cater for new case.
  </br>
  One can also if necessary follow the logic backwards from there (`actions` <- `listeners` <- `app.py` <- `main.py`),
  and adjust things that happen 'higher up'.

## Testing notes ##

Currently this is parcelled out into automatic tests, local testing, live testing.

### Automatic testing ###

Call any of the following:
```bash
make tests-unit # just unit tests
make run & make tests-integration # just integration tests
make run & make tests # all tests
```
Alternatively, open two terminals, call `make run` in one
and `make tests` or `make tests-integration` in the other.

For information about integration tests, _cf._ [tests/README.md](tests/README.md).

### Live testing (local) ###

Tickets should always be tested locally first.
If you have not already done so, [speak to the Botfather](#bot-token) first
to create your own (private) bot for local testing.

To test:

- Start the bot:
    ```bash
    make clean # <- optional
    make build # <- only needed if code or config or assets have changed
    make run
    ```
- Enter the chat group and interact with the bot.

For more explicit logging, set
```yaml
options:
  debug: true
  full-censor-user: false # optional
```
in the [config.yaml](setup/config.yaml) file and restart the bot.
</br>
With this option, logging takes place upon every message,
instead of just relevant messages as per default.

### Live testing (deployed) ###

If the **staging** branch has been changed, the live test bot should be tested!

Do this once:

- Create a group just for you and `@<name-of-live-test-bot>`.
- Ensure you and `@<name-of-live-test-bot>` have admin status.
- `@<name-of-live-test-bot>` only needs rights to delete messages

To test:

- Enter the chat group and interact with the bot.
